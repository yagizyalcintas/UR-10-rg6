"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const defaultDelimiterTags = [
    {
        begin: '{{',
        end: '}}'
    },
    {
        begin: '<<',
        end: '>>'
    }
];
class JsonPlaceholderReplacer {
    constructor(...delimiterTags) {
        this.variablesMap = [];
        if (delimiterTags.length === 0) {
            delimiterTags = defaultDelimiterTags;
        }
        const escapeRegExp = (text) => text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
        this.delimiterTags = delimiterTags.map(tag => (Object.assign(Object.assign({}, tag), { escapedBeginning: escapeRegExp(tag.begin), escapedEnding: escapeRegExp(tag.end) })));
    }
    addVariableMap(variableMap) {
        if (typeof variableMap == 'string') {
            this.variablesMap.push(JSON.parse(variableMap));
        }
        else {
            this.variablesMap.push(variableMap);
        }
        return this;
    }
    replace(json) {
        return this.replaceChildren(json);
    }
    replaceChildren(node) {
        for (const key in node) {
            const attribute = node[key];
            if (typeof attribute == 'object') {
                node[key] = this.replaceChildren(attribute);
            }
            else if (attribute !== undefined) {
                node[key] = this.replaceValue(attribute.toString());
            }
        }
        return node;
    }
    replaceValue(node) {
        const delimiterTagRegex = this.delimiterTags
            .map(delimiterTag => `^${delimiterTag.begin}[^${delimiterTag.end}]+${delimiterTag.end}$`).join('|');
        const regExp = new RegExp(delimiterTagRegex);
        const placeHolderIsInsideStringContext = !regExp.test(node);
        const replacer = (delimiterTag) => (placeHolder) => {
            const path = placeHolder.substr(delimiterTag.begin.length, placeHolder.length - (delimiterTag.begin.length + delimiterTag.end.length));
            const mapCheckResult = this.checkInEveryMap(path);
            if (mapCheckResult === undefined) {
                return placeHolder;
            }
            if (!placeHolderIsInsideStringContext) {
                return mapCheckResult;
            }
            const parsed = JSON.parse(mapCheckResult);
            if (typeof parsed === 'object') {
                return JSON.stringify(parsed);
            }
            return parsed;
        };
        const output = this.delimiterTags
            .reduce((acc, delimiterTag) => {
            const regex = new RegExp(`(${delimiterTag.escapedBeginning}[^${delimiterTag.escapedEnding}]+${delimiterTag.escapedEnding})`, 'g');
            return acc.replace(regex, replacer(delimiterTag));
        }, node);
        try {
            return JSON.parse(output);
        }
        catch (exc) {
            return output;
        }
    }
    checkInEveryMap(path) {
        let result = undefined;
        this.variablesMap.forEach(map => result = this.navigateThroughMap(map, path));
        return result;
    }
    navigateThroughMap(map, path) {
        if (map === undefined) {
            return;
        }
        const shortCircuit = map[path];
        if (shortCircuit !== undefined) {
            return JSON.stringify(shortCircuit);
        }
        let keys = path.split('.');
        const key = keys[0];
        keys.shift();
        return this.navigateThroughMap(map[key], keys.join('.'));
    }
}
exports.JsonPlaceholderReplacer = JsonPlaceholderReplacer;
